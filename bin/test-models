#!/usr/bin/env bash
# test-models — end-to-end validation of models in oompa.json
#
# Usage: test-models [path/to/oompa.json]
#
# For each unique model, launches the agent and asks it to write a result
# file. Then checks all expected files exist. This validates the full
# pipeline: harness CLI → model access → code execution → file I/O.

set -euo pipefail

CONFIG="${1:-oompa.json}"

if [ ! -f "$CONFIG" ]; then
  echo "Config not found: $CONFIG"
  echo "Usage: test-models [path/to/oompa.json]"
  exit 1
fi

# Extract unique model strings from workers[] and review_model
MODELS=$(python3 -c "
import json
with open('$CONFIG') as f:
    cfg = json.load(f)
models = set()
if cfg.get('review_model'):
    models.add(cfg['review_model'])
for w in cfg.get('workers', []):
    if 'model' in w:
        models.add(w['model'])
for m in sorted(models):
    print(m)
")

if [ -z "$MODELS" ]; then
  echo "No models found in $CONFIG"
  exit 1
fi

# Create results directory in /tmp so it doesn't litter the project
RUN_ID=$(python3 -c "import uuid; print(str(uuid.uuid4())[:8])")
RESULTS_DIR="/tmp/oompa_tst_${RUN_ID}"
mkdir -p "$RESULTS_DIR"

MODEL_COUNT=$(echo "$MODELS" | wc -l | tr -d ' ')
echo "Testing $MODEL_COUNT models from $CONFIG"
echo "Results dir: $RESULTS_DIR"
echo ""

# Launch all models in parallel
PIDS=()
MODEL_NAMES=()

while IFS= read -r model; do
  HARNESS="${model%%:*}"
  # Strip reasoning suffix for the model name passed to CLI
  REST="${model#*:}"
  MODEL_NAME="${REST%%:*}"
  # Safe filename: replace slashes and dots
  SAFE_NAME=$(echo "$model" | tr '/:.' '_')

  MODEL_NAMES+=("$SAFE_NAME")
  PROMPT="Write a file called ${RESULTS_DIR}/${SAFE_NAME}_DONE with exactly the text DONE. Nothing else. Just create that one file."

  echo "  launching $model ..."

  case "$HARNESS" in
    claude)
      claude --model "$MODEL_NAME" -p "$PROMPT" --dangerously-skip-permissions --max-turns 3 \
        > "${RESULTS_DIR}/${SAFE_NAME}.log" 2>&1 &
      PIDS+=($!)
      ;;
    codex)
      codex exec --model "$MODEL_NAME" \
        --dangerously-bypass-approvals-and-sandbox \
        --skip-git-repo-check \
        -- "$PROMPT" \
        > "${RESULTS_DIR}/${SAFE_NAME}.log" 2>&1 &
      PIDS+=($!)
      ;;
    *)
      echo "    SKIP (unknown harness: $HARNESS)"
      # Remove from expected list
      unset 'MODEL_NAMES[${#MODEL_NAMES[@]}-1]'
      ;;
  esac
done <<< "$MODELS"

# Wait for all
echo ""
echo "Waiting for all models to complete..."
for pid in "${PIDS[@]}"; do
  wait "$pid" 2>/dev/null || true
done

# Check results
echo ""
echo "Results:"
echo ""

PASS=0
FAIL=0

for safe_name in "${MODEL_NAMES[@]}"; do
  RESULT_FILE="${RESULTS_DIR}/${safe_name}_DONE"
  printf "  %-40s " "$safe_name"

  if [ -f "$RESULT_FILE" ]; then
    CONTENT=$(cat "$RESULT_FILE" | tr -d '[:space:]')
    if [ "$CONTENT" = "DONE" ]; then
      echo "PASS"
      PASS=$((PASS + 1))
    else
      echo "FAIL (file exists but content: '$(head -1 "$RESULT_FILE")')"
      FAIL=$((FAIL + 1))
    fi
  else
    echo "FAIL (no result file)"
    # Show first few lines of log for debugging
    if [ -f "${RESULTS_DIR}/${safe_name}.log" ]; then
      head -5 "${RESULTS_DIR}/${safe_name}.log" | sed 's/^/    /'
    fi
    FAIL=$((FAIL + 1))
  fi
done

echo ""
echo "$PASS passed, $FAIL failed (results in $RESULTS_DIR/)"

[ "$FAIL" -eq 0 ]
